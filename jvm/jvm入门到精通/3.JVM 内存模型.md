# 3.JVM 内存模型

## 回顾

clss cycle

loading  -> linking  -> initalizing

双亲委派：不是集成关系的父加载器，一个成员叫parent；查找从下到上，然后从上到下委托加载

classloader 使用的是一个模板方法



## 遗留问题

**parent是如何指定的？**

任何一个classloader 都一个parent，都没指定，默认构造函数：

- `super(parent)`
- getSystemClassLoader()



**打破双亲委派，是在loadclass里面进行打破的**

1. jdk1.2之前，自定义classloader必须重写loadclass（）

2. ThreadContetClassLoader 可以实现基础类调用实现类代码，通过thread.setContextClassLoader指定

3. 热部署，热启动

   ​	1. osgi tomcat 都有指定自己的 模块指定classloader





## Linking



### verification

验证n见肺腑符合JVM规定

### preparation

静态成员赋默认值

### resolution

将类、方法、属性等符号引用解析为直接引用

常量池中的各种符号引用解析为指针、偏移量等内存地址的直接引用



## Initializing

调用类初始化代码，给静态成员变量赋值



![](E:\ldm-git\book_reading\jvm\jvm入门到精通\prepra_inti.png)

分析上面的输出结果



## 总结

1. load - 默认值-初始值
2. new - 申请内存-默认值-初始值



> DCL 单例
>
> double check loading
>
> 必须加volatile,如果不加volatile 会指令重排，在锁中的对象new出来后，是半初始化状态，外部访问的时候，会出问题;如图字节码，4,7发生指令重排，就会导致引用持有，但是都是默认值
>
> ![](E:\ldm-git\book_reading\jvm\jvm入门到精通\dcl.png)

