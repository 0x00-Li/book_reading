# Redis的持久化RDB、fork、copyonwrite、aof

缓存的常见问题：

击穿

雪崩

穿透

一致性（双写）



## 回顾

redis作为缓存和数据库

缓存：不一定全，可以丢失；追求性能之王

数据库：数据库绝对不能丢；速度+持久性



## 持久化

单机持久化

主从复制

存储层：快照和副本、日志

rdb描述快照

aof描述日志

## RDB

刷盘的都是全量的

### 时点性

从8点开始生成快照，持续20秒，生成的快照，放的是整8点？还是8点20s的？还是8-8.20之间20s的？

实现1:同步进行刷盘：阻塞，暂停对外提供服务

实现2：一边提供服务，一边刷盘

目标：非阻塞，并同时对外提供服务



**管道：**

1. 衔接，前一个命令的输出作为下一个命令的输入
2. 管道会触发创建子进程

> 常规四线个，进程的数据是隔离的！！！
>
> 进阶思想：父进程可以让子进程看到数据！！
>
> export 的子进程修改数据，不影响父进程数据
>
> 父进程的修改页不会破坏子进程

**创建子进程的速度应该是多少？**

> 如果父进程是redis，10g内存
>
> 1. 速度
> 2. 内存空间够不够
>
> 会调用fork():
>
> 速度相对快
>
> 空间相对小

fork的时候，复制，内存映射关系数据；

创建子进程的时候不发生复制

只有主进程要修改数据的时候，才会触发copy on write,

父进程不会把所有的数据都改一遍【在redis场景下，在linux中，父子进程也不可能将所有的数据改一遍】

正常保证时点正确【父子进程对数据的修改，对方看不到】



### save命令实现

>  明确：比如，关机维护

是同步写的命令

### bgsave 实现

fork 创建子进程



### 配置文件出现bgsave 规则：save这个标识

```save 900 1
save 900 1

dbfilename dump.rdb

dir /var/lib/redis/6379



```

### 缺点

不支持拉链，只有一个dump.rdb

丢失数据相对多一点：在刷盘的不同的窗口之前刚好出问题，会丢失窗口的数据

### 优点

类似与java中的序列化，恢复的速度相对快些



## AOF

redis的写操作记录到文件中

### 优点

丢数据少

RDB和AOF可以同时开启；如果开启了AOF只会用AOF恢复；4.0之后AOF中包含RDB全量，增加记录新的写操作



> redis运行了10年，开启了AOF，redis挂了
>
> 1. AOF多大，会很大嘛？恢复的时候会溢出吗？
> 2. 恢复要多久？



### 缺点

1. 体量无限变大

2. 恢复慢

> 目标：设计一个方案让日志，AOF足够小
>
> 参考：hdfs，fsimage+edis.log,让日志值记录增量，然后合并过程

优化方案：

4.0 以前，重写：

	1. 删除抵消的命令
 	2. 合并重复的命令

最终也是纯指令的日志文件

4.0后，重写：

1. 将老的数据RDB到AOF文件中
2. 增量的以指令的方式Append到AOF中

> AOF 是一个混合体，利用了RDB的快，利用了日志的全量









---

**原点：reids是内存数据库**

写操作会触发IO，appendfsync分为三个级别

> appendonly yes
>
> no-append----
>
> aof 混合体开关

- no:由系统决定，可能丢失一个buffer
- always：最可靠的，一直写
- 每秒[everysec]：每秒调flush ,最多丢接近buffer的数据