# 4. mysql 调优 ——索引优化细节

## 索引优化细节

### union all,in ,or 都能使用索引，但是推荐使用in

union all

​		会分成两段执行；底层会执行distinct

in

​		效率比or高，对where中的集合进行筛选

or

​		需要对每个条件进行对比



exists 是两层循环，exists不能查询子查询中的语句

### 范围列可以用到索引

范围条件：< ,>,<=,,>= ,between

范围列可以用索引，但是范围列后无法使用索引，索引列最多使用一个范围列

### 强类型转换会全表扫描

### 更新时分频繁，数据区分度不高的字段不适宜建立索引

更新会变动B+树，更新频繁的字段建立索引会降低数据库性能

类似性别类的

一般区分度在80%以上的时候，可以建立索引可以使用count(distinct（field）)/count(*) 来计算

### 创建索引列，不允许为空，可能会得到不符合预期的结果

### 当需要进行表连接的时候，最好不好超过三张表，因为需要join的字段，数据类型必须一致

join 会执行嵌套循环

### 如果明确知道只有一条结果返回，limit能够提高效率

limit 用来限制输出的，可以控制循环范围

### 单表索引建议控制在5个以内



索引越多，占用空间越多；会增加io

### 单索引字段数不允许超过 5 个

组合索引

### 创建索引的时候应该避免以下错误概念

索引越多越好



过早优化，在不了解系统的情况下进行优化



## 索引监控

`show status like 'Handler_read%'`







## 查询优化

响应时间

连接器，分析器，优化器，执行器

ast

根据生命周期：进行优化



### 查询慢的原因

数据量小的话，差别不大

1. 网络（网络IO）

2. cpu

3. IO

4. 上下文切换

5. 系统调用

6. 生成统计信息

7. 锁等待时间（表锁，行锁）

   > 锁和存储引擎是相关的
   >
   > 行和表支持innodb,表锁支持myisam
   >
   > 行锁退化成表锁
   >
   > 自增锁，间隙锁

### 优化数据访问



1. 查询性能低下的主要原因访问的数据太多，某些查询不可避免需要筛选大量的数据，我们可以通过减少访问数据量的方式进行优化
   1. 确认应用是否在检索大量的需要的数据
   2. 确认mysql服务器是否在分析大量需要的数据
2. 是否向数据库请求 了不需要的数据
   1. 查询不需要的记录
   2. 多表关联时返回全部列
   3. 总是取出全部列
   4. 重复查询相同的数据





###  执行过程优化

1. 查询缓存
2. 查询优化处理
   1. 语法解析器和预处理
      1. 每个表或者索引的页面个数
   2. 查询优化器
      1. 根据陈本预估，选择低成本的执行方案
      2. 在很多的错误的情况下，mysql会选择错误的执行计划
         1. 统计信息不准确
         2. 执行计划的成本估算不等于实际的成本
         3. mysql的最右可能跟你想的不一样
         4. mysql不考虑其他并发执行查询
         5. mysql不考虑不受其控制的操作成本
      3. 优化器优化策略
         1. 静态优化：直接对解析数进行分析，并完成优化
         2. 动态优化：与查询上下文有关，也可能跟取值、索引对应的行数有关
         3. mysql对查询静态优化只需要一次，但对动态优化在每次执行时都需要重新评估
      4. 优化器，优化类型
         1. 重新定义关联表顺序
         2. 将外连接转为内连接，内连接效率高于外连接
         3. 使用等价变换规则，mysql可以使用一些等价变化来简化并规划表达式
         4. 优化count，min，max
         5. 预估并转化为常数表达式，当mysql
         6. 索引覆盖扫描，当索引中的列包含所有索引列
         7. 子查询优化
         8. 等值传播
      5. 关联查询
         1. JOIN实现原理
         2. 案例
      6. 排序优化
         1. 两次传输排序
         2. 单次传输排序
         3. 当需要排序的列，总大小加上orderby的列大小超过了max_length_for_sort_data 定义的字节，mysql会选择双刺排序，反之使用单次排序，当然，用户可以自定义大小







### 优化特定类型的查询



1. 优化count()查询

   1. 总有人认为myisam的count函数比较
   2. 使用近似值
   3. 更复杂的优化

2. 优化关联查询

   1. 确保on和using有索引
   2. 确保groupby和orderby有种表达式只涉及到一个表中的列

3. 优化子查询

   > 尽量使用关联替代，子查询有临时表

4.   优化group by 和distinct

   > 如果

   > 如果对关联查询做分组，并且是按照查找表中的某个别进行分组，那么可以采用查找

5. 优化limit分析

6. 优化union查询  

7. 用户自定义变量

   > @定义变量
   >
   > @@ 系统变量

8.   

   