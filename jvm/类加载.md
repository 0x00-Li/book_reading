# 类加载

## 类加载过程

加载 -> 连接（验证、准备、解析） -> 初始化 -> 使用 -> 卸载

验证：验证class文件是否符合规范

准备：静态变量初始化和分配内存

解析：符号引用替换为直接引用

![link](/Users/zero/Documents/book_reading/jvm/class_link.png)

## 类加载器



- 启动类加载器（`Bootstrap`）：加载`<JAVA_HOME>/lib`路径下的核心类库

- 扩展类加载器（`Extension`）：加载`<JAVA_HOME>/lib/ext`l路径下的
- 系统类加载器（`System`）：加载系统类路径`classpath`，也就是我们经常用到的`classpath`路径，一般情况该类加载器是程序中默认的类加载器

### 为什么自定义类加载器

- 资源隔离

- - `web`容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，因此要保证每个应用程序的类库都是独立的，相互隔离
  - `web`容器有自己依赖的类库，不能与应用程序的类库混淆，基于安全考虑，应该让容器的类库和程序的类库隔离

- 加密保护

- - 公司的一些核心类库，可能会把字节码加密，这样加载类的时候就必须对字节码进行解密

- 其他来源加载类

- - 字节码是放在数据库、硬盘其他路径、甚至是在云端

- 类重新加载

- - `JVM`中类对象的唯一性：类加载器实例+完整类名
  - 程序运行中，类内容发生变化，创建自定义加载器实例重新加载类，达到的热部署效果。

### 特殊情况

`Java`应用中存在着很多服务提供者接口（`Service Provider Interface，SPI`），这些接口允许第三方为它们提供实现，如常见的`SPI`有`JDBC、JNDI`等，这些`SPI`的接口属于`Java`核心库，一般存在`rt.jar`包中，由启动类加载器（`Bootstrap`）加载，而`SPI`的第三方实现代码则是作为`Java`应用所依赖的`jar`包被存放在`classpath`路径下。

由于`SPI`接口中的代码需要加载第三方实现类并调用其相关函数，但`SPI`的核心接口类是由启动类加载器（`Bootstrap`）加载的，`Bootstrap`加载器无法直接加载`SPI`的实现类。

在这种情况下，我们就需要一种特殊的类加载器来加载第三方的类库，它就是线程上下文类加载器，线程的上下文类加载器默认设置的就是系统类加载器（`System`）。

![classloader](/Users/zero/Documents/book_reading/jvm/classloader.png)