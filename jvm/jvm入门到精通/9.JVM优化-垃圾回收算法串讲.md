# 9.JVM优化-垃圾回收算法串讲

## 回顾

垃圾回收器的分类和应用



Serial 是单线程回收，Serial Old 是多线程回收

CMS 是并发回收，工作线程和回收线程同时进行



垃圾回收器的发展是伴随着内存的增长进行演变的



### CMS

四阶段:

1. 初始标记
2. 并发标记
3. 重新标记
4. 并发回收

> cms 中的并发说的是，工作线程和回收线程同时工作

### 初始标记

GC roots:线程栈变量 、 静态变量 、常量池、JNI指针

STW 很短

### 并发标记

最耗时的阶段，但是不产生STW



### 重新标记

标记，在并发标记后饮用发生变更的对象

STW也比较短

**并发标记算法：**

难点：在标记对象的过程中，工作线程在整工作

**三色标记算法：**

白：未标记对象

灰：自身被标记，成员变量未被标记

黑：自己标记了，成员变量都标记完成

**漏标：**

在remark记过程中，黑色指向了白色；如果不对黑色重新扫描，则会漏标，会吧白色对象当做没有新引用指向从而回收掉

在并发标记的过程中，工作线程对上产生了应用变更

**解决漏标的办法：**

1. incremental update 增量更新，关注引用的增加

   把黑色重新标记为灰色，重新扫描当前的应用

2.   SATB SNAPSHOT at the begining -关注引用删除

   当当b->d 小时是，要把这个应用的推到GC的UI站，保证d还能被GC扫描到

###  并发清理



## 从线程角度理解 CMS

并发标记阶段：适当降低了吞吐量，提升了响应时间

并发清理阶段产生的垃圾，称为浮动垃圾；浮动垃圾在下一轮回收的时候，会进行回收掉



## CMS缺点

内存碎片

浮动垃圾

## G1

之前的垃圾回收器，面对大内存的时候，STW会很长；G1 是彻底改变了回收模型

G1 是一种服务端应用试用的垃圾收集器，目标是用在多核、大内存的机器上，它大多数情况可以实现指定的GC暂停事件，同时还能保持较高吞吐量

![](E:\ldm-git\book_reading\jvm\jvm入门到精通\g1模型.png)

整体是分而治之的思想

主要分为Region,逻辑分代模型,主要四大类

old survivor eden humongous

回收算法使用的是：serial

**特点**

1. 并发收集
2. 压缩空闲空间不会延长GC暂停时间
3.   更易预测的GC暂停时间
4.   适用不需要实现很高的吞吐量的场景
5.  

> 三色标记
>
> 把对象分成不同的颜色
>
> 
>
> 颜色指针
>
> 64bit 使用三个表示颜色
>
> 

G1 的Region不是固定的老年代或者年轻代，但是在某一时间是固定的



## 基本概念

> card table 跟各种垃圾回收器的关系不大，帮助各种垃圾回收器，回收垃圾
>
> 由于做YGC时，需要扫描整个OLD

1.   CSet=Collection Set

   那些region需要被回收

      一组可被回收的分区的集合

2.   RSet=RememberedSet

   记录了其他Region中的对象到本Region的引用

   价值在于是得垃圾回收器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可

   大概占用10%空间

3.   

   > 阿里多租户JVM
   >
   > 1. 每个组合单空间
   > 2. session based gc



## 新老年代的比例

5%~60%

一般不用手工指定

也不需要手工指定，因为G1预测停顿时间的基准









超哥region的50%就成为大对象



## 为什么G1用SATB？

灰色-> 白色，引用消失时，如果没有黑色指向白色，引用会被push到堆栈

下次扫描时拿到这个引用，由于有RSet的存在 ，不需要扫描整个堆查找指向白色的引用，效率比较高

## GC何时触发

- YGC

  - eden空间不足
  - 多线程并行执行：

- FGC

  > 10 以前是串行 的，10以后才是并行的

  - 扩内存
  - 提供CPU性能（回收的快，业务逻辑产生对象速度固定，垃圾回收越快，内存空间越大）
  - 降低mixedGC触发阀值【相当于CMS】,提前触发MixedGC



> 调优目标：不要产生FGC
>
> mixed GC 过程
>
> 初始标记 STW
>
> 并发标记
>
> 重新标记 STW
>
> 并发筛选回收 ：回收最需要回收的区域；STW



## RSet 与复制效率

由于Rset的存在，那么每次给对象赋引用的时候，就得做一些额外的操作

指的是RSet中做的 一些额外记录（在GC中被称为写屏障，这个写屏障不等于内存屏障）